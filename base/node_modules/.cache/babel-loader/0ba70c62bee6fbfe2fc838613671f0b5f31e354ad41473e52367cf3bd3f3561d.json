{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Container_1 = require(\"../Container\");\nvar Token_1 = require(\"../Token\");\nvar CannotInjectError_1 = require(\"../error/CannotInjectError\");\n/**\n * Injects a service into a class property or constructor parameter.\n */\nfunction InjectMany(typeOrName) {\n  return function (target, propertyName, index) {\n    if (!typeOrName) typeOrName = function () {\n      return Reflect.getMetadata(\"design:type\", target, propertyName);\n    };\n    Container_1.Container.registerHandler({\n      object: target,\n      propertyName: propertyName,\n      index: index,\n      value: function (containerInstance) {\n        var identifier;\n        if (typeof typeOrName === \"string\") {\n          identifier = typeOrName;\n        } else if (typeOrName instanceof Token_1.Token) {\n          identifier = typeOrName;\n        } else {\n          identifier = typeOrName();\n        }\n        if (identifier === Object) throw new CannotInjectError_1.CannotInjectError(target, propertyName);\n        return containerInstance.getMany(identifier);\n      }\n    });\n  };\n}\nexports.InjectMany = InjectMany;","map":{"version":3,"mappings":";;;;;AAAA;AACA;AACA;AAiBA;;;AAGA,oBAA2BA,UAAyD;EAChF,OAAO,UAASC,MAAc,EAAEC,YAAoB,EAAEC,KAAc;IAEhE,IAAI,CAACH,UAAU,EACXA,UAAU,GAAG;MAAM,OAACI,OAAe,CAACC,WAAW,CAAC,aAAa,EAAEJ,MAAM,EAAEC,YAAY,CAAC;IAAjE,CAAiE;IAExFI,qBAAS,CAACC,eAAe,CAAC;MACtBC,MAAM,EAAEP,MAAM;MACdC,YAAY,EAAEA,YAAY;MAC1BC,KAAK,EAAEA,KAAK;MACZM,KAAK,EAAE,2BAAiB;QACpB,IAAIC,UAAe;QACnB,IAAI,OAAOV,UAAU,KAAK,QAAQ,EAAE;UAChCU,UAAU,GAAGV,UAAU;SAE1B,MAAM,IAAIA,UAAU,YAAYW,aAAK,EAAE;UACpCD,UAAU,GAAGV,UAAU;SAE1B,MAAM;UACHU,UAAU,GAAGV,UAAU,EAAE;;QAG7B,IAAIU,UAAU,KAAKE,MAAM,EACrB,MAAM,IAAIC,qCAAiB,CAACZ,MAAM,EAAEC,YAAY,CAAC;QAErD,OAAOY,iBAAiB,CAACC,OAAO,CAAML,UAAU,CAAC;MACrD;KACH,CAAC;EACN,CAAC;AACL;AA7BAM","names":["typeOrName","target","propertyName","index","Reflect","getMetadata","Container_1","registerHandler","object","value","identifier","Token_1","Object","CannotInjectError_1","containerInstance","getMany","exports"],"sources":["C:\\reactjs\\bnk_fe_training\\base\\src\\decorators\\InjectMany.ts"],"sourcesContent":["import {Container} from \"../Container\";\nimport {Token} from \"../Token\";\nimport {CannotInjectError} from \"../error/CannotInjectError\";\n\n/**\n * Injects a service into a class property or constructor parameter.\n */\nexport function InjectMany(type?: (type?: any) => Function): Function;\n\n/**\n * Injects a service into a class property or constructor parameter.\n */\nexport function InjectMany(serviceName?: string): Function;\n\n/**\n * Injects a service into a class property or constructor parameter.\n */\nexport function InjectMany(token: Token<any>): Function;\n\n/**\n * Injects a service into a class property or constructor parameter.\n */\nexport function InjectMany(typeOrName?: ((type?: any) => Function)|string|Token<any>): Function {\n    return function(target: Object, propertyName: string, index?: number) {\n\n        if (!typeOrName)\n            typeOrName = () => (Reflect as any).getMetadata(\"design:type\", target, propertyName);\n\n        Container.registerHandler({\n            object: target,\n            propertyName: propertyName,\n            index: index,\n            value: containerInstance => {\n                let identifier: any;\n                if (typeof typeOrName === \"string\") {\n                    identifier = typeOrName;\n\n                } else if (typeOrName instanceof Token) {\n                    identifier = typeOrName;\n\n                } else {\n                    identifier = typeOrName();\n                }\n\n                if (identifier === Object)\n                    throw new CannotInjectError(target, propertyName);\n\n                return containerInstance.getMany<any>(identifier);\n            }\n        });\n    };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}