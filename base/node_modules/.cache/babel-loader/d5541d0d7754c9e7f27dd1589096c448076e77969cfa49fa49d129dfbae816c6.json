{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Container_1 = require(\"./Container\");\nvar MissingProvidedServiceTypeError_1 = require(\"./error/MissingProvidedServiceTypeError\");\nvar ServiceNotFoundError_1 = require(\"./error/ServiceNotFoundError\");\nvar Token_1 = require(\"./Token\");\n/**\n * TypeDI can have multiple containers.\n * One container is ContainerInstance.\n */\nvar ContainerInstance = /** @class */function () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function ContainerInstance(id) {\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n    /**\n     * All registered services.\n     */\n    this.services = [];\n    this.id = id;\n  }\n  /**\n   * Checks if the service with given name or type is registered service container.\n   * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n   */\n  ContainerInstance.prototype.has = function (identifier) {\n    return !!this.findService(identifier);\n  };\n  /**\n   * Retrieves the service with given name or type from the service container.\n   * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n   */\n  ContainerInstance.prototype.get = function (identifier) {\n    var globalContainer = Container_1.Container.of(undefined);\n    var service = globalContainer.findService(identifier);\n    var scopedService = this.findService(identifier);\n    if (service && service.global === true) return this.getServiceValue(identifier, service);\n    if (scopedService) return this.getServiceValue(identifier, scopedService);\n    if (service && this !== globalContainer) {\n      var clonedService = Object.assign({}, service);\n      clonedService.value = undefined;\n      var value = this.getServiceValue(identifier, clonedService);\n      this.set(identifier, value);\n      return value;\n    }\n    return this.getServiceValue(identifier, service);\n  };\n  /**\n   * Gets all instances registered in the container of the given service identifier.\n   * Used when service defined with multiple: true flag.\n   */\n  ContainerInstance.prototype.getMany = function (id) {\n    var _this = this;\n    return this.filterServices(id).map(function (service) {\n      return _this.getServiceValue(id, service);\n    });\n  };\n  /**\n   * Sets a value for the given type or service name in the container.\n   */\n  ContainerInstance.prototype.set = function (identifierOrServiceMetadata, value) {\n    var _this = this;\n    if (identifierOrServiceMetadata instanceof Array) {\n      identifierOrServiceMetadata.forEach(function (v) {\n        return _this.set(v);\n      });\n      return this;\n    }\n    if (typeof identifierOrServiceMetadata === \"string\" || identifierOrServiceMetadata instanceof Token_1.Token) {\n      return this.set({\n        id: identifierOrServiceMetadata,\n        value: value\n      });\n    }\n    if (typeof identifierOrServiceMetadata === \"object\" && identifierOrServiceMetadata.service) {\n      return this.set({\n        id: identifierOrServiceMetadata.service,\n        value: value\n      });\n    }\n    if (identifierOrServiceMetadata instanceof Function) {\n      return this.set({\n        type: identifierOrServiceMetadata,\n        id: identifierOrServiceMetadata,\n        value: value\n      });\n    }\n    // const newService: ServiceMetadata<any, any> = arguments.length === 1 && typeof identifierOrServiceMetadata === \"object\"  && !(identifierOrServiceMetadata instanceof Token) ? identifierOrServiceMetadata : undefined;\n    var newService = identifierOrServiceMetadata;\n    var service = this.findService(newService.id);\n    if (service && service.multiple !== true) {\n      Object.assign(service, newService);\n    } else {\n      this.services.push(newService);\n    }\n    return this;\n  };\n  /**\n   * Removes services with a given service identifiers (tokens or types).\n   */\n  ContainerInstance.prototype.remove = function () {\n    var _this = this;\n    var ids = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      ids[_i] = arguments[_i];\n    }\n    ids.forEach(function (id) {\n      _this.filterServices(id).forEach(function (service) {\n        _this.services.splice(_this.services.indexOf(service), 1);\n      });\n    });\n    return this;\n  };\n  /**\n   * Completely resets the container by removing all previously registered services from it.\n   */\n  ContainerInstance.prototype.reset = function () {\n    this.services = [];\n    return this;\n  };\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Filters registered service in the with a given service identifier.\n   */\n  ContainerInstance.prototype.filterServices = function (identifier) {\n    return this.services.filter(function (service) {\n      if (service.id) return service.id === identifier;\n      if (service.type && identifier instanceof Function) return service.type === identifier || identifier.prototype instanceof service.type;\n      return false;\n    });\n  };\n  /**\n   * Finds registered service in the with a given service identifier.\n   */\n  ContainerInstance.prototype.findService = function (identifier) {\n    return this.services.find(function (service) {\n      if (service.id) {\n        if (identifier instanceof Object && service.id instanceof Token_1.Token && identifier.service instanceof Token_1.Token) {\n          return service.id === identifier.service;\n        }\n        return service.id === identifier;\n      }\n      if (service.type && identifier instanceof Function) return service.type === identifier; // todo: not sure why it was here || identifier.prototype instanceof service.type;\n      return false;\n    });\n  };\n  /**\n   * Gets service value.\n   */\n  ContainerInstance.prototype.getServiceValue = function (identifier, service) {\n    var _a;\n    // find if instance of this object already initialized in the container and return it if it is\n    if (service && service.value !== undefined) return service.value;\n    // if named service was requested and its instance was not found plus there is not type to know what to initialize,\n    // this means service was not pre-registered and we throw an exception\n    if ((!service || !service.type) && (!service || !service.factory) && (typeof identifier === \"string\" || identifier instanceof Token_1.Token)) throw new ServiceNotFoundError_1.ServiceNotFoundError(identifier);\n    // at this point we either have type in service registered, either identifier is a target type\n    var type = undefined;\n    if (service && service.type) {\n      type = service.type;\n    } else if (service && service.id instanceof Function) {\n      type = service.id;\n    } else if (identifier instanceof Function) {\n      type = identifier;\n      // } else if (identifier instanceof Object && (identifier as { service: Token<any> }).service instanceof Token) {\n      //     type = (identifier as { service: Token<any> }).service;\n    }\n    // if service was not found then create a new one and register it\n    if (!service) {\n      if (!type) throw new MissingProvidedServiceTypeError_1.MissingProvidedServiceTypeError(identifier);\n      service = {\n        type: type\n      };\n      this.services.push(service);\n    }\n    // setup constructor parameters for a newly initialized service\n    var paramTypes = type && Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:paramtypes\", type) : undefined;\n    var params = paramTypes ? this.initializeParams(type, paramTypes) : [];\n    // if factory is set then use it to create service instance\n    var value;\n    if (service.factory) {\n      // filter out non-service parameters from created service constructor\n      // non-service parameters can be, lets say Car(name: string, isNew: boolean, engine: Engine)\n      // where name and isNew are non-service parameters and engine is a service parameter\n      params = params.filter(function (param) {\n        return param !== undefined;\n      });\n      if (service.factory instanceof Array) {\n        // use special [Type, \"create\"] syntax to allow factory services\n        // in this case Type instance will be obtained from Container and its method \"create\" will be called\n        value = (_a = this.get(service.factory[0]))[service.factory[1]].apply(_a, params);\n      } else {\n        // regular factory function\n        value = service.factory.apply(service, params.concat([this]));\n      }\n    } else {\n      // otherwise simply create a new object instance\n      if (!type) throw new MissingProvidedServiceTypeError_1.MissingProvidedServiceTypeError(identifier);\n      params.unshift(null);\n      // \"extra feature\" - always pass container instance as the last argument to the service function\n      // this allows us to support javascript where we don't have decorators and emitted metadata about dependencies\n      // need to be injected, and user can use provided container to get instances he needs\n      params.push(this);\n      value = new (type.bind.apply(type, params))();\n    }\n    if (service && !service.transient && value) service.value = value;\n    if (type) this.applyPropertyHandlers(type, value);\n    return value;\n  };\n  /**\n   * Initializes all parameter types for a given target service class.\n   */\n  ContainerInstance.prototype.initializeParams = function (type, paramTypes) {\n    var _this = this;\n    return paramTypes.map(function (paramType, index) {\n      var paramHandler = Container_1.Container.handlers.find(function (handler) {\n        return handler.object === type && handler.index === index;\n      });\n      if (paramHandler) return paramHandler.value(_this);\n      if (paramType && paramType.name && !_this.isTypePrimitive(paramType.name)) {\n        return _this.get(paramType);\n      }\n      return undefined;\n    });\n  };\n  /**\n   * Checks if given type is primitive (e.g. string, boolean, number, object).\n   */\n  ContainerInstance.prototype.isTypePrimitive = function (param) {\n    return [\"string\", \"boolean\", \"number\", \"object\"].indexOf(param.toLowerCase()) !== -1;\n  };\n  /**\n   * Applies all registered handlers on a given target class.\n   */\n  ContainerInstance.prototype.applyPropertyHandlers = function (target, instance) {\n    var _this = this;\n    Container_1.Container.handlers.forEach(function (handler) {\n      if (typeof handler.index === \"number\") return;\n      if (handler.object.constructor !== target && !(target.prototype instanceof handler.object.constructor)) return;\n      instance[handler.propertyName] = handler.value(_this);\n    });\n  };\n  return ContainerInstance;\n}();\nexports.ContainerInstance = ContainerInstance;","map":{"version":3,"mappings":"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","names":["id","ContainerInstance","identifier","findService","globalContainer","Container_1","of","undefined","service","scopedService","global","getServiceValue","clonedService","Object","assign","value","set","filterServices","map","identifierOrServiceMetadata","Array","forEach","v","Token_1","Function","type","newService","multiple","services","push","_i","ids","_this","splice","indexOf","filter","prototype","find","factory","ServiceNotFoundError_1","MissingProvidedServiceTypeError_1","paramTypes","Reflect","getMetadata","params","initializeParams","get","unshift","bind","apply","transient","applyPropertyHandlers","paramType","index","paramHandler","handlers","object","handler","name","isTypePrimitive","param","toLowerCase","target","instance","constructor","propertyName","exports"],"sources":["C:\\reactjs\\bnk_fe_training\\base\\src\\ContainerInstance.ts"],"sourcesContent":["import {Container} from \"./Container\";\nimport {MissingProvidedServiceTypeError} from \"./error/MissingProvidedServiceTypeError\";\nimport {ServiceNotFoundError} from \"./error/ServiceNotFoundError\";\nimport {Token} from \"./Token\";\nimport {ObjectType} from \"./types/ObjectType\";\nimport {ServiceIdentifier} from \"./types/ServiceIdentifier\";\nimport {ServiceMetadata} from \"./types/ServiceMetadata\";\n\n/**\n * TypeDI can have multiple containers.\n * One container is ContainerInstance.\n */\nexport class ContainerInstance {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Container instance id.\n     */\n    id: any;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * All registered services.\n     */\n    private services: ServiceMetadata<any, any>[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(id: any) {\n        this.id = id;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if the service with given name or type is registered service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    has<T>(type: ObjectType<T>): boolean;\n\n    /**\n     * Checks if the service with given name or type is registered service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    has<T>(id: string): boolean;\n\n    /**\n     * Checks if the service with given name or type is registered service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    has<T>(id: Token<T>): boolean;\n\n    /**\n     * Checks if the service with given name or type is registered service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    has<T>(identifier: ServiceIdentifier): boolean {\n        return !!this.findService(identifier);\n    }\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(type: ObjectType<T>): T;\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(id: string): T;\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(id: Token<T>): T;\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(id: { service: T }): T;\n\n    /**\n     * Retrieves the service with given name or type from the service container.\n     * Optionally, parameters can be passed in case if instance is initialized in the container for the first time.\n     */\n    get<T>(identifier: ServiceIdentifier<T>): T {\n\n        const globalContainer = Container.of(undefined);\n        let service = globalContainer.findService(identifier);\n        let scopedService = this.findService(identifier);\n\n        if (service && service.global === true)\n            return this.getServiceValue(identifier, service);\n\n        if (scopedService)\n            return this.getServiceValue(identifier, scopedService);\n\n        if (service && this !== globalContainer) {\n            const clonedService = Object.assign({}, service);\n            clonedService.value = undefined;\n            const value = this.getServiceValue(identifier, clonedService);\n            this.set(identifier, value);\n            return value;\n        }\n\n        return this.getServiceValue(identifier, service);\n    }\n\n    /**\n     * Gets all instances registered in the container of the given service identifier.\n     * Used when service defined with multiple: true flag.\n     */\n    getMany<T>(id: string): T[];\n\n    /**\n     * Gets all instances registered in the container of the given service identifier.\n     * Used when service defined with multiple: true flag.\n     */\n    getMany<T>(id: Token<T>): T[];\n\n    /**\n     * Gets all instances registered in the container of the given service identifier.\n     * Used when service defined with multiple: true flag.\n     */\n    getMany<T>(id: string|Token<T>): T[] {\n        return this.filterServices(id).map(service => this.getServiceValue(id, service));\n    }\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set<T, K extends keyof T>(service: ServiceMetadata<T, K>): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(type: Function, value: any): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(name: string, value: any): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(token: Token<any>, value: any): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(token: ServiceIdentifier, value: any): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set<T, K extends keyof T>(values: ServiceMetadata<T, K>[]): this;\n\n    /**\n     * Sets a value for the given type or service name in the container.\n     */\n    set(identifierOrServiceMetadata: ServiceIdentifier|ServiceMetadata<any, any>|(ServiceMetadata<any, any>[]), value?: any): this {\n        if (identifierOrServiceMetadata instanceof Array) {\n            identifierOrServiceMetadata.forEach((v: any) => this.set(v));\n            return this;\n        }\n        if (typeof identifierOrServiceMetadata === \"string\" || identifierOrServiceMetadata instanceof Token) {\n            return this.set({ id: identifierOrServiceMetadata, value: value });\n        }\n        if (typeof identifierOrServiceMetadata === \"object\" && (identifierOrServiceMetadata as { service: Token<any> }).service) {\n            return this.set({ id: (identifierOrServiceMetadata as { service: Token<any> }).service, value: value });\n        }\n        if (identifierOrServiceMetadata instanceof Function) {\n            return this.set({ type: identifierOrServiceMetadata, id: identifierOrServiceMetadata, value: value });\n        }\n\n        // const newService: ServiceMetadata<any, any> = arguments.length === 1 && typeof identifierOrServiceMetadata === \"object\"  && !(identifierOrServiceMetadata instanceof Token) ? identifierOrServiceMetadata : undefined;\n        const newService: ServiceMetadata<any, any> = identifierOrServiceMetadata as any;\n        const service = this.findService(newService.id);\n        if (service && service.multiple !== true) {\n            Object.assign(service, newService);\n        } else {\n            this.services.push(newService);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes services with a given service identifiers (tokens or types).\n     */\n    remove(...ids: ServiceIdentifier[]): this {\n        ids.forEach(id => {\n            this.filterServices(id).forEach(service => {\n                this.services.splice(this.services.indexOf(service), 1);\n            });\n        });\n        return this;\n    }\n\n    /**\n     * Completely resets the container by removing all previously registered services from it.\n     */\n    reset(): this {\n        this.services = [];\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Filters registered service in the with a given service identifier.\n     */\n    private filterServices(identifier: ServiceIdentifier): ServiceMetadata<any, any>[] {\n        return this.services.filter(service => {\n            if (service.id)\n                return service.id === identifier;\n\n            if (service.type && identifier instanceof Function)\n                return service.type === identifier || identifier.prototype instanceof service.type;\n\n            return false;\n        });\n    }\n\n    /**\n     * Finds registered service in the with a given service identifier.\n     */\n    private findService(identifier: ServiceIdentifier): ServiceMetadata<any, any>|undefined {\n        return this.services.find(service => {\n            if (service.id) {\n                if (identifier instanceof Object &&\n                    service.id instanceof Token &&\n                    (identifier as any).service instanceof Token) {\n                    return service.id === (identifier as any).service;\n                }\n\n                return service.id === identifier;\n            }\n\n            if (service.type && identifier instanceof Function)\n                return service.type === identifier; // todo: not sure why it was here || identifier.prototype instanceof service.type;\n\n            return false;\n        });\n    }\n\n    /**\n     * Gets service value.\n     */\n    private getServiceValue(identifier: ServiceIdentifier, service: ServiceMetadata<any, any>|undefined): any {\n\n        // find if instance of this object already initialized in the container and return it if it is\n        if (service && service.value !== undefined)\n            return service.value;\n\n        // if named service was requested and its instance was not found plus there is not type to know what to initialize,\n        // this means service was not pre-registered and we throw an exception\n        if ((!service || !service.type) &&\n            (!service || !service.factory) &&\n            (typeof identifier === \"string\" || identifier instanceof Token))\n            throw new ServiceNotFoundError(identifier);\n\n        // at this point we either have type in service registered, either identifier is a target type\n        let type = undefined;\n        if (service && service.type) {\n            type = service.type;\n\n        } else if (service && service.id instanceof Function) {\n            type = service.id;\n\n        } else if (identifier instanceof Function) {\n            type = identifier;\n\n        // } else if (identifier instanceof Object && (identifier as { service: Token<any> }).service instanceof Token) {\n        //     type = (identifier as { service: Token<any> }).service;\n        }\n\n        // if service was not found then create a new one and register it\n        if (!service) {\n            if (!type)\n                throw new MissingProvidedServiceTypeError(identifier);\n\n            service = { type: type };\n            this.services.push(service);\n        }\n\n        // setup constructor parameters for a newly initialized service\n        const paramTypes = type && Reflect && (Reflect as any).getMetadata ? (Reflect as any).getMetadata(\"design:paramtypes\", type) : undefined;\n        let params: any[] = paramTypes ? this.initializeParams(type, paramTypes) : [];\n\n        // if factory is set then use it to create service instance\n        let value: any;\n        if (service.factory) {\n\n            // filter out non-service parameters from created service constructor\n            // non-service parameters can be, lets say Car(name: string, isNew: boolean, engine: Engine)\n            // where name and isNew are non-service parameters and engine is a service parameter\n            params = params.filter(param => param !== undefined);\n\n            if (service.factory instanceof Array) {\n                // use special [Type, \"create\"] syntax to allow factory services\n                // in this case Type instance will be obtained from Container and its method \"create\" will be called\n                value = (this.get(service.factory[0]) as any)[service.factory[1]](...params);\n\n            } else { // regular factory function\n                value = service.factory(...params, this);\n            }\n\n        } else {  // otherwise simply create a new object instance\n            if (!type)\n                throw new MissingProvidedServiceTypeError(identifier);\n\n            params.unshift(null);\n\n            // \"extra feature\" - always pass container instance as the last argument to the service function\n            // this allows us to support javascript where we don't have decorators and emitted metadata about dependencies\n            // need to be injected, and user can use provided container to get instances he needs\n            params.push(this);\n\n            value = new (type.bind.apply(type, params))();\n        }\n\n        if (service && !service.transient && value)\n            service.value = value;\n\n        if (type)\n            this.applyPropertyHandlers(type, value);\n\n        return value;\n    }\n\n    /**\n     * Initializes all parameter types for a given target service class.\n     */\n    private initializeParams(type: Function, paramTypes: any[]): any[] {\n        return paramTypes.map((paramType, index) => {\n            const paramHandler = Container.handlers.find(handler => handler.object === type && handler.index === index);\n            if (paramHandler)\n                return paramHandler.value(this);\n\n            if (paramType && paramType.name && !this.isTypePrimitive(paramType.name)) {\n                return this.get(paramType);\n            }\n\n            return undefined;\n        });\n    }\n\n    /**\n     * Checks if given type is primitive (e.g. string, boolean, number, object).\n     */\n    private isTypePrimitive(param: string): boolean {\n        return [\"string\", \"boolean\", \"number\", \"object\"].indexOf(param.toLowerCase()) !== -1;\n    }\n\n    /**\n     * Applies all registered handlers on a given target class.\n     */\n    private applyPropertyHandlers(target: Function, instance: { [key: string]: any }) {\n        Container.handlers.forEach(handler => {\n            if (typeof handler.index === \"number\") return;\n            if (handler.object.constructor !== target && !(target.prototype instanceof handler.object.constructor))\n                return;\n\n            instance[handler.propertyName] = handler.value(this);\n        });\n    }\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}